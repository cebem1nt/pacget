#!/bin/env python3
import argparse, sys, subprocess, requests, json, os

from typing import Optional, Iterable, Any, Union
from itertools import zip_longest

BASE_URL = "https://aur.archlinux.org/"
RPC_URL = "rpc/v5/"

def err(msg: str):
    sys.stderr.write(msg + '\n')
    sys.exit(1)

def rpc(*params: Iterable[Any]) -> Any:
    final = BASE_URL + RPC_URL

    for par in params:
        final += '/' + str(par)

    resp = requests.get(final, timeout=10)
    return resp.json()

class Package:
    def __init__(
        self, 
        name: str, 
        dest: Optional[str]
    ):
        self.name = name
        self.dest = dest
        self.deps: list[Package] = []

    def __clone(self, cli: list[str]):
        proc = subprocess.run(cli)

        if proc.returncode != 0:
            err("Could not clone PKGBUILD")

    def clone(
        self, 
        do_force: bool = False,
        do_install: bool = False,
        pull_deps: bool = False,
    ):
        url = BASE_URL + self.name + ".git"
        cli = ["git", "clone", url]

        found: dict = self.lookup()
        
        if not found and not do_force:
            err(f"Package {self.name} was not found")

        if self.dest:
            cli.append(self.dest)

            if os.path.exists(os.path.join(self.dest, ".git")):
                cli = ["git", "-C", self.dest, "pull"]
        else:
            # When clonning with no specific destination, it will be cloned to
            # cwd/pkg.name
            self.dest = self.name

        self.__clone(cli)
                
        if pull_deps or do_install:
            # This block is unreachable from dependency
            self.pull_deps(found)
            if do_install: self.install()

    def pull_deps(self, info: Optional[dict]):
        if not info:
            err("Could not pull dependencies, No info")

        deps: list[str] = info["results"][0]["Depends"]
        make_deps: list[str] = info["results"][0]["MakeDepends"]

        querry = subprocess.run(
            ["pacman", "-Sp"] + deps,
            capture_output=True,
            text=True
        )

        for line in querry.stderr.splitlines():
            _, name = line.split("error: target not found: ")

            self.deps.append(
                Package(name, self.dest + f"/deps/{name}" if self.dest else None)
            )

        for pkg in self.deps:
            pkg.clone()

        # print(make_deps)

    def lookup(self) -> Optional[Any]:
        response = rpc("info", self.name)
        amount_found = response.get("resultcount")

        if amount_found != 0:
            return response

        return None

    def install(self):

        for dep in self.deps:
            cli = ["makepkg", "-si", "-D", dep.dest]
            subprocess.run(cli)

        subprocess.run(["makepkg", "-si", "-D", self.dest])


def main(args: argparse.Namespace):
    pkgs = []

    for name, dest in zip_longest(args.names, args.dest):
        if not dest and args.storage_dir:
            dest = args.storage_dir + '/' + name

        pkg = Package(name, dest)
        pkgs.append(pkg)
    
    for pkg in pkgs:
        ret = pkg.clone(args.force, args.install, args.pull_deps)

        if ret != 0: 
            sys.exit(ret)


if __name__ == "__main__":
    p = argparse.ArgumentParser(
        description="Search & Get PKGBUILD's from Arch User Repository"
    )
    
    p.add_argument("names",                                    nargs='*', help="Name[s] of PKGBUILD[s] to search for")
    p.add_argument("-d", "--dest",  metavar="DIR", default=[], nargs='+', help="Optional directories where to clone to")
    p.add_argument("-S", "--storage-dir", metavar="DIR",                  help="Default directory where to clone to")    
    p.add_argument("-i", "--install",     action="store_true",            help="After clonning, automatically install")
    p.add_argument("-f", "--force",       action="store_true",            help="Do not check if PKGBUILD[s] exist[s], forcefully clone")
    p.add_argument("-s", "--search",      action="store_true",            help="Search for PKGBUILD[s] instead of cloning")
    p.add_argument("-v", "--version",     action="store_true",            help="If searching, also print version")
    p.add_argument("-p", "--pull-deps",   action="store_true",            help="Pull dependency PKGBUILD[s] as well")
    p.add_argument("-D", "--detailed",    action="store_true",            help="If searching, print more detailed information (Description, souce URL)")

    args = p.parse_args()

    if len(args.names) == 0:
        p.print_help()
        sys.exit(1)

    if args.dest and len(args.dest) != len(args.names):
        print("Amount of directories doesn't match the amount of PKGBUILD[s] names")
        sys.exit(1)

    main(args)
