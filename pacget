#!/bin/env python3
import argparse, sys, subprocess, requests, json, os

BASE_URL = "https://aur.archlinux.org/"
RPC_URL = "rpc/v5/"

def print_pkg_info(pkg: object, is_detailed: bool, version: bool):
    if os.environ.get("TERM") != "dumb":
        pkg["Description"] = "\033[95m" + pkg["Description"] + "\033[0m" # Magenta
 
    if version:
        print(pkg["Name"] + ' ' + pkg["Version"])
    else:
        print(pkg["Name"])

    if is_detailed:
        print("   Info: ", pkg["Description"])
        print(" Source: ", pkg["URL"])
        print('')

def search_multiple(pkgs: list[str], is_detailed: bool, version: bool):
    search_url = BASE_URL + RPC_URL + "info?arg[]="
    search_url += pkgs[0]
    pkgs.pop(0)

    for pkg in pkgs:
        search_url += f"&arg[]={pkg}"

    response = requests.get(search_url)
    response_json = json.loads(response.content)

    for item in response_json["results"]:
        print_pkg_info(item, is_detailed, version)

def search_one(pkg_string: str, is_detailed: bool, version: bool):
    search_url = BASE_URL + RPC_URL + "search/" + pkg_string + "?by=name" 
    response = requests.get(search_url)

    response_json = json.loads(response.content)

    for item in response_json["results"]:
        print_pkg_info(item, is_detailed, version)

def search(pkgs: list[str], is_detailed: bool, version: bool): 
    if len(pkgs) == 1:
        search_one(pkgs[0], is_detailed, version)
    else:
        search_multiple(pkgs, is_detailed, version)

def pac_exists(url: str):
    check_proc = subprocess.run(
        ["git", "ls-remote", url, "--exit-code"], 
        stdout=subprocess.PIPE
    )

    return len(check_proc.stdout) == 0

def clone_pkgbuild(pkg: str, dest=None):
    cli = ["git", "clone", BASE_URL + pkg + ".git"]
    if dest:
        dest = os.path.expanduser(dest)
        cli.append(dest)

    proc = subprocess.run(cli)
    if proc.returncode != 0:
        print("Could not clone PKGBUILD")
        sys.exit(1)


def clone(
    pkgs: list[str], 
    dests: list[str], 
    do_force: bool, 
    do_install: bool, 
    default_dir=None
):
    if not do_force:
        for i, pkg in enumerate(pkgs):
            if pac_exists(BASE_URL + pkg + ".git"):
                continue

            print(f"Could not find remote for {pkg}. Skipping")

            pkgs.pop(i)
            if dests: dests.pop(i)

    if not dests:
        for pkg in pkgs:
            dest = os.path.join(default_dir, pkg) if default_dir else pkg
            clone_pkgbuild(pkg, dest)
            dests.append(dest)
    else:
        for pkg, dest in zip(pkgs, dests):
            clone_pkgbuild(pkg, dest)
    
    if do_install:
        for pkg_dir in dests:
            subprocess.run(["makepkg", "-si", "-D", pkg_dir])


def main(args: any):
    try:
        if args.search:
            search(args.names, args.detailed, args.version)

        elif args.names:
            clone(args.names, 
                  [] if not args.dest else args.dest, 
                  args.force, 
                  args.install,
                  args.storage_dir)

    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Search & Get PKGBUILD's from Arch User Repository"
    )
    
    parser.add_argument("names",                                    nargs='*', help="Name[s] of PKGBUILD[s] to search for")
    parser.add_argument("-d", "--dest",        metavar="DIR",       nargs='+', help="Optional directories where to clone to")
    parser.add_argument("-S", "--storage-dir", metavar="DIR",                  help="Default directory where to clone to by default")    
    parser.add_argument("-i", "--install",     action="store_true",            help="After clonning, automatically install")
    parser.add_argument("-f", "--force",       action="store_true",            help="Do not check if PKGBUILD[s] exist[s], forcefully clone")
    parser.add_argument("-s", "--search",      action="store_true",            help="Search for PKGBUILD[s] instead of cloning")
    parser.add_argument("-v", "--version",     action="store_true",            help="If searching, also print version")
    parser.add_argument("-D", "--detailed",    action="store_true",            help="If searching, print more detailed information (Description, souce URL)")

    args = parser.parse_args()

    if len(args.names) == 0:
        parser.print_help()
        sys.exit(1)

    if args.dest and len(args.dest) != len(args.names):
        print("Amount of directories doesn't match the amount of PKGBUILD[s] names")
        sys.exit(1)

    main(args)
