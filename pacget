#!/bin/env python3
import argparse, sys, subprocess, requests, json, os

from typing import Optional, Iterable, Any, Union
from itertools import zip_longest

BASE_URL = "https://aur.archlinux.org/"
RPC_URL = "rpc/v5/"

def err(msg: str):
    sys.stderr.write(msg + '\n')
    sys.exit(1)

def run(cli: list[str], capture_output=False):
    proc = subprocess.run(
        cli, text=True, capture_output=capture_output
    )

    return proc.stderr

def rpc(
    *params: Iterable[Any]
) -> Any:
    final = BASE_URL + RPC_URL

    for par in params:
        final += '/' + str(par)

    resp = requests.get(final, timeout=10)
    return resp.json()

class Package:
    def __init__(
        self, 
        name: str, 
        dest: Optional[str]
    ):
        self.name = name
        self.dest = dest
        self.deps: list[Package] = []
        self.make_deps: list[Package] = []

    def __clone(self, cli: list[str]):
        proc = subprocess.run(cli)

        if proc.returncode != 0:
            err("Could not clone PKGBUILD")

    def clone(
        self, 
        do_force: bool = False,
        do_install: bool = False,
        pull_deps: bool = False,
    ):
        url = BASE_URL + self.name + ".git"
        cli = ["git", "clone", url]

        found: dict = self.lookup()
        
        if not found and not do_force:
            err(f"Package {self.name} was not found")

        if self.dest:
            cli.append(self.dest)

            if os.path.exists(os.path.join(self.dest, ".git")):
                cli = ["git", "-C", self.dest, "pull"]
        else:
            # When clonning with no specific destination, it will be cloned to
            # cwd/pkg.name
            self.dest = self.name

        self.__clone(cli)
                
        if pull_deps or do_install:
            # This block is unreachable from dependency
            self.pull_deps(found)
            if do_install: self.install()

    def __populate_deps(
        self, 
        deps: list[str],
        is_make_deps: bool = False
    ):
        output = run(["pacman", "-Sp"] + deps, True)

        out = []
        sub_dir = "/make_deps/" if is_make_deps else "/deps/"

        for line in output.splitlines():
            _, name = line.split("error: target not found: ")
            out.append(
                Package(name, self.dest + f"{sub_dir}{name}" if self.dest else None)
            )

        return out

    def pull_deps(self, info: Optional[dict]):
        if not info:
            err("Could not pull dependencies, No info")

        deps = info["results"][0]["Depends"]
        self.deps = self.__populate_deps(deps)

        if "MakeDepends" in info["results"][0]:
            make_deps = info["results"][0]["MakeDepends"]
            self.make_deps = self.__populate_deps(make_deps, is_make_deps=True)

            for pkg in self.make_deps:
                pkg.clone()

        for pkg in self.deps:
            pkg.clone()

    def lookup(self) -> Optional[Any]:
        response = rpc("info", self.name)
        amount_found = response.get("resultcount")

        if amount_found != 0:
            return response

        return None

    def uninstall(self):
        run(["sudo", "pacman", "-Rns", self.name])

    def install(self):
        installed = []

        for dep in self.make_deps + self.deps:
            # Install dependencies
            proc = subprocess.run(["makepkg", "-si", "-D", dep.dest])
            if proc.returncode != 0:
                break

            installed.append(dep)
        else:
            run(["makepkg", "-si", "-D", self.dest])

            if self.make_deps:
                run(
                    ["sudo", "pacman", "-Rns"] + 
                    [d.name for d in self.make_deps]
                )

            return

        # Failure. Some package was not installed.
        sys.stderr.write("Could not install package. Cleanup\n")

        run(
            ["sudo", "pacman", "-Rns"] + 
            [i.name for i in installed]
        )

def print_results(results: list[dict], is_brief: bool):
    for res in results:
        name = res["Name"]

        if is_brief:
            print(name)

        else:
            version = res["Version"]
            desc = res["Description"]
            
            print(f"\n- \x1b[34m{name}\x1b[0m {version}")
            print(f"  {desc}")

def search(pkgs: list[str], is_brief: bool, by="name"):
    for pkg in pkgs:
        out = rpc("search", f"{pkg}?by={by}")

        if not is_brief:
            print(f"\n--------- Results for {pkg} ---------")

        print_results(
            out["results"],
            is_brief
        )

def main(args: argparse.Namespace):
    try:
        if args.search:
            search(args.names, args.brief)
            return

        pkgs = []

        for name, dest in zip_longest(args.names, args.dest):
            if not dest and args.storage_dir:
                dest = args.storage_dir + '/' + name

            pkg = Package(name, dest)
            pkgs.append(pkg)
        
        for pkg in pkgs:
            ret = pkg.clone(args.force, args.install, args.pull_deps)

            if ret != 0: 
                sys.exit(ret)
                
    except (KeyboardInterrupt, EOFError) as e:
        sys.exit(1)


if __name__ == "__main__":
    p = argparse.ArgumentParser(
        description="Search & Get PKGBUILD's from Arch User Repository"
    )
    
    p.add_argument("names",                                    nargs='*', help="Name[s] of PKGBUILD[s] to search for")
    p.add_argument("-i", "--install",     action="store_true",            help="After clonning, automatically install")
    p.add_argument("-s", "--search",      action="store_true",            help="Search for PKGBUILD[s] instead of cloning")
    p.add_argument("-f", "--force",       action="store_true",            help="Do not check if PKGBUILD[s] exist[s], forcefully clone")
    p.add_argument("-d", "--dest",  metavar="DIR", default=[], nargs='+', help="Optional directories where to clone to")
    p.add_argument("-p", "--pull-deps",   action="store_true",            help="Pull dependency PKGBUILD[s] as well")
    p.add_argument("-b", "--brief",       action="store_true",            help="If searching, do not output additional info (description, version)")    
    p.add_argument("--storage-dir",       metavar="DIR",                  help="Default directory where to clone to")    

    args = p.parse_args()

    if len(args.names) == 0:
        p.print_help()
        sys.exit(1)

    if args.dest and len(args.dest) != len(args.names):
        print("Amount of directories doesn't match the amount of PKGBUILD[s] names")
        sys.exit(1)

    main(args)
